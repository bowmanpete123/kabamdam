# Test Plan: CLI Interface (2.1)

## Goals
- Verify `wrap-up` logic (parsing -> rendering -> injection).
- Verify default path handling.
- Verify path override via CLI options.
- Verify robust error handling for missing files and partial markers.

## Test Suite: `tests/test_cli.py`

### Verification Strategy
The `cli_target` function will return a dictionary representing the state of the system after execution:
- `exit_code`: The return code of the process.
- `svg_exists`: Boolean indicating if the expected SVG was created.
- `readme_updated`: Boolean indicating if the README contains the expected injection.
- `stdout_snippet`: A specific string expected in the output (e.g., "Error", "Warning").

Each `TestCase` will define the `expected` dictionary to match this state.

### Scenarios
1. **Default Execution**: `exit_code: 0`, `svg_exists: True`, `readme_updated: True`.
2. **Overriding Paths**: `exit_code: 0`, `svg_exists: True` (for custom path).
3. **Missing Roadmap**: `exit_code: 2` (or non-zero), `stdout_snippet: "not found"`.
4. **Update Markers**: `readme_updated: True`.
5. **Missing Markers**: `stdout_snippet: "Warning"`, `readme_updated: False`.
6. **Broken/Partial Markers**: `exit_code: 1`, `stdout_snippet: "Incomplete"`.
7. **Relative Path (root)**: Checks that the injected link is correct for root location.
8. **Relative Path (nested)**: Checks that the injected link is correct for nested location.



## Tools
- `pytest-kedge` for scenario management.
- `typer.testing.CliRunner` for invoking the CLI.
- `mocker` (pytest-mock) for isolating side effects.
